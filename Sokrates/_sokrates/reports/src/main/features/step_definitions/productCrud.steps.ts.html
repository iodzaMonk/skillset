<html>
<head>
    <title>features/step_definitions/productCrud.steps.ts</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">features/step_definitions/productCrud.steps.ts (<b>131</b> lines of code) (<a href="productCrud.steps.ts">raw</a>):</h3>
<div id="editor">import assert from &quot;assert&quot;;
import {
  After,
  Before,
  DataTable,
  Given,
  Then,
  When,
} from &quot;@cucumber/cucumber&quot;;
import { ProductCrudFixture } from &quot;../support/productCrudFixture.ts&quot;;

type ProductCrudWorld = {
  fixture: ProductCrudFixture;
};

Before(function (this: ProductCrudWorld) {
  this.fixture = new ProductCrudFixture();
});

After(async function (this: ProductCrudWorld) {
  await this.fixture.cleanup();
});

Given(
  &quot;I am authenticated for product management&quot;,
  async function (this: ProductCrudWorld) {
    await this.fixture.authenticate();
  },
);

Given(
  &quot;I am not authenticated for product management&quot;,
  function (this: ProductCrudWorld) {
    this.fixture.signOut();
  },
);

Given(
  &quot;the following products already exist for me:&quot;,
  async function (this: ProductCrudWorld, table: DataTable) {
    await this.fixture.seedMyProducts(table.hashes());
  },
);

Given(
  &quot;another user owns the following products:&quot;,
  async function (this: ProductCrudWorld, table: DataTable) {
    await this.fixture.seedForeignProducts(table.hashes());
  },
);

When(
  &quot;I create a product with:&quot;,
  async function (this: ProductCrudWorld, table: DataTable) {
    await this.fixture.createProduct(table.hashes()[0] ?? {});
  },
);

When(
  &quot;I update the product titled {string} with:&quot;,
  async function (this: ProductCrudWorld, title: string, table: DataTable) {
    await this.fixture.updateProduct(title, table.hashes()[0] ?? {});
  },
);

When(&quot;I list my products&quot;, async function (this: ProductCrudWorld) {
  await this.fixture.listMyProducts();
});

When(
  &quot;I delete the product titled {string}&quot;,
  async function (this: ProductCrudWorld, title: string) {
    await this.fixture.deleteProduct(title);
  },
);

Then(
  &quot;the product request should have status {int}&quot;,
  function (this: ProductCrudWorld, status: number) {
    const response = this.fixture.response;
    assert.ok(response, &quot;No product response captured&quot;);
    assert.strictEqual(response.status, status);
  },
);

Then(
  &quot;the product response payload should include:&quot;,
  function (this: ProductCrudWorld, table: DataTable) {
    const response = this.fixture.response;
    assert.ok(response?.body?.data, &quot;Expected product data in response&quot;);
    const expected = table.hashes()[0] ?? {};
    for (const [key, value] of Object.entries(expected)) {
      assert.strictEqual(
        String((response.body.data as Record&lt;string, unknown&gt;)[key]),
        value,
      );
    }
  },
);

Then(
  &quot;the product error message should contain {string}&quot;,
  function (this: ProductCrudWorld, snippet: string) {
    const response = this.fixture.response;
    assert.ok(response?.body?.message, &quot;Expected an error message in response&quot;);
    const message = String(response.body.message);
    assert.ok(
      message.includes(snippet),
      `Expected &quot;${message}&quot; to include &quot;${snippet}&quot;`,
    );
  },
);

Then(
  &quot;the product list should include titles:&quot;,
  function (this: ProductCrudWorld, table: DataTable) {
    const response = this.fixture.response;
    assert.ok(response?.body?.data, &quot;Expected data in list response&quot;);
    const titles = (response.body.data as Array&lt;Record&lt;string, unknown&gt;&gt;).map(
      (p) =&gt; String(p.title),
    );
    for (const row of table.hashes()) {
      assert.ok(
        titles.includes(row.title),
        `Expected list to include ${row.title}`,
      );
    }
  },
);

Then(&quot;the product list should be empty&quot;, function (this: ProductCrudWorld) {
  const response = this.fixture.response;
  assert.ok(response?.body?.data, &quot;Expected data in list response&quot;);
  assert.strictEqual(
    (response.body.data as Array&lt;unknown&gt;).length,
    0,
    &quot;Expected no products&quot;,
  );
});

Then(
  &quot;the product message should be {string}&quot;,
  function (this: ProductCrudWorld, message: string) {
    const response = this.fixture.response;
    assert.ok(response?.body?.message, &quot;Expected a message in response&quot;);
    assert.strictEqual(response.body.message, message);
  },
);
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/typescript");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
