<html>
<head>
    <title>features/support/productService.ts</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">features/support/productService.ts (<b>282</b> lines of code) (<a href="productService.ts">raw</a>):</h3>
<div id="editor">import bcrypt from &quot;bcryptjs&quot;;
import { randomUUID } from &quot;crypto&quot;;
import { Prisma, Category } from &quot;@prisma/client&quot;;
import { prisma } from &quot;../../lib/prisma.ts&quot;;

type ProductRow = Record&lt;string, string&gt;;

export type ProductResponse = {
  status: number;
  body: Record&lt;string, unknown&gt;;
};

function parseCategory(value: string | undefined): Category {
  if (!value) {
    throw new Error(&quot;Category is required for product rows&quot;);
  }
  const normalized = value.trim() as Category;
  if (!Object.values(Category).includes(normalized)) {
    throw new Error(`Unknown category &quot;${value}&quot;`);
  }
  return normalized;
}

function parsePrice(value: string | undefined): number {
  const parsed = Number(value);
  if (Number.isNaN(parsed)) {
    throw new Error(`Invalid price &quot;${value}&quot;`);
  }
  return parsed;
}

type ReviewerOptions = {
  email?: string;
  country?: string;
};

type OwnerOptions = {
  name?: string;
  email?: string;
  country?: string;
};

class ProductService {
  private ownerId: string | null = null;
  private products = new Map&lt;string, string&gt;();
  private reviewers = new Map&lt;string, string&gt;();
  private reviewIds: string[] = [];
  private extraOwnerIds: string[] = [];

  async seed(rows: ProductRow[]) {
    for (const row of rows) {
      const ownerOverrides: OwnerOptions = {
        name: row[&quot;owner name&quot;]?.trim(),
        email: row[&quot;owner email&quot;]?.trim(),
        country: row[&quot;owner country&quot;]?.trim(),
      };
      const ownerId =
        ownerOverrides.name ||
        ownerOverrides.email ||
        ownerOverrides.country
          ? await this.createOwner(ownerOverrides)
          : await this.ensureOwner();

      const title = row.title?.trim();
      if (!title) {
        throw new Error(&quot;Each product row must include a title&quot;);
      }

      const category = parseCategory(row.category);
      const price = parsePrice(row.price);
      const description = row.description?.trim() || `${title} description`;

      const product = await prisma.posts.create({
        data: {
          user_id: ownerId,
          title,
          description,
          price,
          category,
        },
        select: { id: true },
      });

      this.products.set(title, product.id);
    }
  }

  async seedReviews(rows: ProductRow[]) {
    const ratingRollups = new Map&lt;
      string,
      { total: number; count: number }
    &gt;();

    for (const row of rows) {
      const productTitle = row.product?.trim() || row.title?.trim();
      if (!productTitle) {
        throw new Error(&quot;Each review row must include a product title&quot;);
      }
      const productId = this.products.get(productTitle);
      if (!productId) {
        throw new Error(`No product found for review with title &quot;${productTitle}&quot;`);
      }

      const reviewerName = row.reviewer?.trim();
      if (!reviewerName) {
        throw new Error(&quot;Each review row must include a reviewer column&quot;);
      }
      const reviewerEmail =
        row[&quot;reviewer email&quot;]?.trim() || row.email?.trim() || undefined;
      const reviewerCountry =
        row[&quot;reviewer country&quot;]?.trim() || row.country?.trim() || undefined;
      const reviewerId = await this.ensureReviewer(reviewerName, {
        email: reviewerEmail,
        country: reviewerCountry,
      });

      const text = row.text?.trim() || &quot;Great work!&quot;;
      const rating = row.rating ? Number(row.rating) : null;
      if (row.rating &amp;&amp; Number.isNaN(rating)) {
        throw new Error(`Invalid rating &quot;${row.rating}&quot; for ${productTitle}`);
      }

      const review = await prisma.reviews.create({
        data: {
          user_id: reviewerId,
          product_id: productId,
          text,
          rating: rating ?? undefined,
          date: new Date(),
        },
        select: { id: true },
      });

      this.reviewIds.push(review.id);

      if (rating !== null) {
        const current = ratingRollups.get(productId) ?? { total: 0, count: 0 };
        ratingRollups.set(productId, {
          total: current.total + rating,
          count: current.count + 1,
        });
      }
    }

    for (const [productId, { total, count }] of ratingRollups.entries()) {
      await prisma.posts.update({
        where: { id: productId },
        data: {
          rating: total / count,
          ratingCount: count,
        },
      });
    }
  }

  async fetchByTitle(title: string): Promise&lt;ProductResponse&gt; {
    const productId = this.products.get(title);
    if (!productId) {
      throw new Error(`No product seeded with title &quot;${title}&quot;`);
    }
    return this.fetchBySlug(productId);
  }

  async fetchBySlug(slug: string): Promise&lt;ProductResponse&gt; {
    if (!slug) {
      return {
        status: 400,
        body: { message: &quot;Invalid product ID&quot; },
      };
    }

    try {
      const product = await prisma.posts.findUnique({
        where: { id: slug },
        include: {
          users: {
            select: {
              id: true,
              name: true,
              country: true,
              email: true,
            },
          },
          reviews: {
            include: {
          users: {
            select: {
              id: true,
              name: true,
              country: true,
              email: true,
            },
          },
              replies: {
                select: {
                  id: true,
                  date: true,
                  text: true,
                },
              },
            },
            orderBy: { date: &quot;desc&quot; },
          },
        },
      });

      if (!product) {
        return {
          status: 404,
          body: { message: &quot;Product not found&quot; },
        };
      }

      return {
        status: 200,
        body: {
          ...product,
          image_url: &quot;/no-image.svg&quot;,
        },
      };
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        return {
          status: 400,
          body: { message: &quot;Invalid product ID&quot; },
        };
      }
      throw error;
    }
  }

  async cleanup() {
    if (this.reviewIds.length &gt; 0) {
      await prisma.reviews.deleteMany({
        where: { id: { in: this.reviewIds } },
      });
      this.reviewIds = [];
    }

    const productIds = Array.from(this.products.values());
    if (productIds.length &gt; 0) {
      await prisma.posts.deleteMany({
        where: { id: { in: productIds } },
      });
      this.products.clear();
    }

    if (this.ownerId) {
      await prisma.users
        .delete({ where: { id: this.ownerId } })
        .catch(() =&gt; null);
      this.ownerId = null;
    }
    if (this.extraOwnerIds.length &gt; 0) {
      await prisma.users.deleteMany({
        where: { id: { in: this.extraOwnerIds } },
      });
      this.extraOwnerIds = [];
    }
    if (this.reviewers.size &gt; 0) {
      await prisma.users.deleteMany({
        where: { id: { in: Array.from(this.reviewers.values()) } },
      });
      this.reviewers.clear();
    }
  }

  private async ensureOwner() {
    if (this.ownerId) return this.ownerId;
    const hashed = await bcrypt.hash(&quot;ProductPass123!&quot;, 10);
    const user = await prisma.users.create({
      data: {
        name: &quot;Product Fixture&quot;,
        email: `product-${randomUUID()}@example.com`,
        password: hashed,
        country: &quot;US&quot;,
      },
      select: { id: true },
    });
    this.ownerId = user.id;
    return user.id;
  }

  private async createOwner(options: OwnerOptions) {
    const hashed = await bcrypt.hash(&quot;ProductOwnerPass123!&quot;, 10);
    const user = await prisma.users.create({
      data: {
        name: options.name ?? &quot;Product Fixture&quot;,
        email:
          options.email ??
          `owner-${randomUUID()}@example.com`,
        password: hashed,
        country: options.country ?? &quot;US&quot;,
      },
      select: { id: true },
    });
    this.extraOwnerIds.push(user.id);
    return user.id;
  }

  private async ensureReviewer(name: string, options: ReviewerOptions = {}) {
    const existing = this.reviewers.get(name);
    if (existing) return existing;
    const hashed = await bcrypt.hash(&quot;ReviewerPass123!&quot;, 10);
    const safeEmail =
      options.email ??
      `${name.toLowerCase().replace(/\s+/g, &quot;.&quot;)}@example.com`;
    const user = await prisma.users.create({
      data: {
        name,
        email: safeEmail,
        password: hashed,
        country: options.country ?? &quot;US&quot;,
      },
      select: { id: true },
    });
    this.reviewers.set(name, user.id);
    return user.id;
  }
}

export const productService = new ProductService();
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/typescript");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
