<html>
<head>
    <title>app/product/[slug]/components/useComments.ts</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">app/product/[slug]/components/useComments.ts (<b>468</b> lines of code) (<a href="useComments.ts">raw</a>):</h3>
<div id="editor">&quot;use client&quot;;

import axios from &quot;axios&quot;;
import { FormEvent, useEffect, useMemo, useState } from &quot;react&quot;;

import type { Comment } from &quot;@/types/Comment&quot;;

const MAX_REPLY_DEPTH = 3;

type ReplyContext = {
  id: string;
  depth: number;
};

type UseCommentsArgs = {
  productId: string;
  user: { id: string } | null | undefined;
};

const updateCommentTree = (comments: Comment[], updated: Comment): Comment[] =&gt;
  comments.map((comment) =&gt; {
    if (comment.id === updated.id) {
      const mergedReplies =
        updated.replies !== undefined
          ? updated.replies
          : comment.replies
            ? [...comment.replies]
            : undefined;

      return {
        ...comment,
        ...updated,
        replies: mergedReplies,
      };
    }

    if (comment.replies &amp;&amp; comment.replies.length &gt; 0) {
      return {
        ...comment,
        replies: updateCommentTree(comment.replies, updated),
      };
    }

    return comment;
  });

const removeCommentFromTree = (comments: Comment[], id: string): Comment[] =&gt;
  comments
    .filter((comment) =&gt; comment.id !== id)
    .map((comment) =&gt;
      comment.replies &amp;&amp; comment.replies.length &gt; 0
        ? {
            ...comment,
            replies: removeCommentFromTree(comment.replies, id),
          }
        : comment,
    );

const insertReplyIntoTree = (
  comments: Comment[],
  parentId: string,
  reply: Comment,
): Comment[] =&gt;
  comments.map((comment) =&gt; {
    if (comment.id === parentId) {
      const existingReplies = comment.replies ?? [];
      return {
        ...comment,
        replies: [...existingReplies, reply],
      };
    }

    if (comment.replies &amp;&amp; comment.replies.length &gt; 0) {
      return {
        ...comment,
        replies: insertReplyIntoTree(comment.replies, parentId, reply),
      };
    }

    return comment;
  });

const collectCommentIds = (items: Comment[]): Set&lt;string&gt; =&gt; {
  const ids = new Set&lt;string&gt;();
  const walk = (list: Comment[]) =&gt; {
    list.forEach((item) =&gt; {
      ids.add(item.id);
      if (item.replies &amp;&amp; item.replies.length &gt; 0) {
        walk(item.replies);
      }
    });
  };

  walk(items);
  return ids;
};

export const useComments = ({ productId, user }: UseCommentsArgs) =&gt; {
  const [comments, setComments] = useState&lt;Comment[]&gt;([]);
  const [isLoading, setIsLoading] = useState(true);
  const [loadError, setLoadError] = useState&lt;string | null&gt;(null);

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [message, setMessage] = useState(&quot;&quot;);
  const [formError, setFormError] = useState&lt;string | null&gt;(null);

  const [activeMenuId, setActiveMenuId] = useState&lt;string | null&gt;(null);
  const [editingCommentId, setEditingCommentId] = useState&lt;string | null&gt;(null);
  const [editingValue, setEditingValue] = useState(&quot;&quot;);
  const [isSavingEdit, setIsSavingEdit] = useState(false);
  const [editError, setEditError] = useState&lt;string | null&gt;(null);

  const [replyContext, setReplyContext] = useState&lt;ReplyContext | null&gt;(null);
  const [replyMessage, setReplyMessage] = useState(&quot;&quot;);
  const [isSubmittingReply, setIsSubmittingReply] = useState(false);
  const [replyError, setReplyError] = useState&lt;string | null&gt;(null);

  const [actionError, setActionError] = useState&lt;string | null&gt;(null);
  const [expandedThreads, setExpandedThreads] = useState&lt;Set&lt;string&gt;&gt;(
    () =&gt; new Set(),
  );
  const [rating, setRating] = useState(0);
  const [hoverRating, setHoverRating] = useState(0);
  const [editingRating, setEditingRating] = useState(0);
  const [editingHoverRating, setEditingHoverRating] = useState(0);
  const [editingParentId, setEditingParentId] = useState&lt;string | null&gt;(null);

  const replyingToId = replyContext?.id ?? null;

  useEffect(() =&gt; {
    let cancelled = false;
    setIsLoading(true);
    setLoadError(null);

    axios
      .get&lt;Comment[]&gt;(`/api/product/${productId}/reviews`)
      .then((response) =&gt; {
        if (!cancelled) {
          setComments(response.data ?? []);
          setExpandedThreads(new Set());
        }
      })
      .catch((err) =&gt; {
        if (!cancelled) {
          const fallback =
            err.response?.data?.message ?? &quot;Unable to load comments&quot;;
          setLoadError(fallback);
        }
      })
      .finally(() =&gt; {
        if (!cancelled) {
          setIsLoading(false);
        }
      });

    return () =&gt; {
      cancelled = true;
    };
  }, [productId]);

  const hasComments = useMemo(() =&gt; comments.length &gt; 0, [comments]);

  const handleMessageChange = (value: string) =&gt; {
    setMessage(value);
    if (formError) setFormError(null);
  };

  const handleSubmit = async (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; {
    event.preventDefault();
    const trimmed = message.trim();

    if (!user) {
      setFormError(&quot;You need to be signed in to leave a comment.&quot;);
      return;
    }

    if (!trimmed) {
      setFormError(&quot;Comment cannot be empty.&quot;);
      return;
    }

    if (rating &lt;= 0 || rating &gt; 5) {
      setFormError(&quot;Please select a star rating.&quot;);
      return;
    }

    try {
      setIsSubmitting(true);
      setFormError(null);
      setActionError(null);
      const response = await axios.post&lt;Comment&gt;(
        `/api/product/${productId}/reviews`,
        {
          text: trimmed,
          rating,
        },
      );

      setComments((prev) =&gt; [response.data, ...prev]);
      setMessage(&quot;&quot;);
      setRating(0);
      setHoverRating(0);
    } catch (err) {
      const message =
        axios.isAxiosError(err) &amp;&amp; err.response?.data?.message
          ? err.response.data.message
          : &quot;Unable to submit comment.&quot;;
      setFormError(message);
    } finally {
      setIsSubmitting(false);
    }
  };

  const toggleMenu = (commentId: string) =&gt; {
    setActiveMenuId((prev) =&gt; (prev === commentId ? null : commentId));
  };

  const startEditing = (comment: Comment) =&gt; {
    setEditingCommentId(comment.id);
    setEditingValue(comment.text);
    setEditError(null);
    setActionError(null);
    setActiveMenuId(null);
    setReplyContext(null);
    setReplyMessage(&quot;&quot;);
    setReplyError(null);
    setEditingParentId(comment.parent_id ?? null);
    const initialRating = comment.parent_id ? 0 : (comment.rating ?? 0);
    setEditingRating(initialRating);
    setEditingHoverRating(initialRating);
  };

  const handleCancelEdit = () =&gt; {
    if (isSavingEdit) return;
    setEditingCommentId(null);
    setEditingValue(&quot;&quot;);
    setEditError(null);
    setActionError(null);
    setReplyContext(null);
    setReplyMessage(&quot;&quot;);
    setReplyError(null);
    setEditingParentId(null);
    setEditingRating(0);
    setEditingHoverRating(0);
  };

  const handleEditingValueChange = (value: string) =&gt; {
    setEditingValue(value);
    if (editError) setEditError(null);
    if (actionError) setActionError(null);
  };

  const handleReplyValueChange = (value: string) =&gt; {
    setReplyMessage(value);
    if (replyError) setReplyError(null);
    if (actionError) setActionError(null);
  };

  const handleEdit = async (commentId: string) =&gt; {
    const trimmed = editingValue.trim();

    if (!trimmed) {
      setEditError(&quot;Comment cannot be empty.&quot;);
      return;
    }

    const isTopLevelEditing = editingParentId === null;

    if (isTopLevelEditing) {
      if (editingRating &lt;= 0 || editingRating &gt; 5) {
        setEditError(&quot;Please select a star rating.&quot;);
        return;
      }
    }

    try {
      setIsSavingEdit(true);
      setEditError(null);
      setActionError(null);

      const payload: { id: string; text: string; rating?: number | null } = {
        id: commentId,
        text: trimmed,
      };

      if (isTopLevelEditing) {
        payload.rating = editingRating;
      }

      const response = await axios.patch&lt;Comment&gt;(
        `/api/product/${productId}/reviews`,
        payload,
      );

      setComments((prev) =&gt; updateCommentTree(prev, response.data));
      setEditingCommentId(null);
      setEditingValue(&quot;&quot;);
      setActionError(null);
      setEditingParentId(null);
      setEditingRating(0);
      setEditingHoverRating(0);
    } catch (err) {
      const message =
        axios.isAxiosError(err) &amp;&amp; err.response?.data?.message
          ? err.response.data.message
          : &quot;Unable to update comment.&quot;;
      setEditError(message);
      setActionError(message);
    } finally {
      setIsSavingEdit(false);
    }
  };

  const handleDelete = async (commentId: string) =&gt; {
    try {
      setActionError(null);
      setEditError(null);
      setActiveMenuId(null);

      await axios.delete(`/api/product/${productId}/reviews`, {
        data: { id: commentId },
      });

      let updatedTree: Comment[] = [];
      setComments((prev) =&gt; {
        const nextTree = removeCommentFromTree(prev, commentId);
        updatedTree = nextTree;
        return nextTree;
      });

      if (replyContext?.id === commentId) {
        setReplyContext(null);
        setReplyMessage(&quot;&quot;);
        setReplyError(null);
      }

      setExpandedThreads((prev) =&gt; {
        if (!prev.size) return prev;
        const validIds = collectCommentIds(updatedTree);
        const next = new Set&lt;string&gt;();
        prev.forEach((id) =&gt; {
          if (validIds.has(id)) next.add(id);
        });
        return next;
      });
    } catch (err) {
      const message =
        axios.isAxiosError(err) &amp;&amp; err.response?.data?.message
          ? err.response.data.message
          : &quot;Unable to delete comment.&quot;;
      setActionError(message);
    }
  };

  const beginReply = (commentId: string, depth: number) =&gt; {
    if (!user) {
      setActionError(&quot;You need to be signed in to leave a reply.&quot;);
      return;
    }

    if (depth &gt;= MAX_REPLY_DEPTH - 1) {
      setActionError(&quot;Maximum reply depth reached.&quot;);
      return;
    }

    if (replyContext?.id === commentId) {
      if (!isSubmittingReply) {
        setReplyContext(null);
        setReplyMessage(&quot;&quot;);
        setReplyError(null);
      }
      return;
    }

    setReplyContext({ id: commentId, depth });
    setReplyMessage(&quot;&quot;);
    setReplyError(null);
    setActionError(null);
    setActiveMenuId(null);
    setEditingCommentId(null);
    setEditingValue(&quot;&quot;);
    setEditError(null);

    setExpandedThreads((prev) =&gt; {
      if (prev.has(commentId)) return prev;
      const next = new Set(prev);
      next.add(commentId);
      return next;
    });
  };

  const handleCancelReply = () =&gt; {
    if (isSubmittingReply) return;
    setReplyContext(null);
    setReplyMessage(&quot;&quot;);
    setReplyError(null);
  };

  const handleSubmitReply = async (commentId: string) =&gt; {
    const target = replyContext;
    if (!target || target.id !== commentId) return;

    const trimmed = replyMessage.trim();

    if (!trimmed) {
      setReplyError(&quot;Reply cannot be empty.&quot;);
      return;
    }

    if (!user) {
      setReplyError(&quot;You need to be signed in to reply.&quot;);
      return;
    }

    if (target.depth &gt;= MAX_REPLY_DEPTH - 1) {
      setReplyError(&quot;Maximum reply depth reached.&quot;);
      return;
    }

    try {
      setIsSubmittingReply(true);
      setReplyError(null);
      setActionError(null);

      const response = await axios.post&lt;Comment&gt;(
        `/api/product/${productId}/reviews`,
        {
          text: trimmed,
          parentId: commentId,
        },
      );

      setComments((prev) =&gt;
        insertReplyIntoTree(prev, commentId, response.data),
      );
      setReplyContext(null);
      setReplyMessage(&quot;&quot;);

      setExpandedThreads((prev) =&gt; {
        const next = new Set(prev);
        next.add(commentId);
        return next;
      });
    } catch (err) {
      const message =
        axios.isAxiosError(err) &amp;&amp; err.response?.data?.message
          ? err.response.data.message
          : &quot;Unable to submit reply.&quot;;
      setReplyError(message);
      setActionError(message);
    } finally {
      setIsSubmittingReply(false);
    }
  };

  const toggleThreadVisibility = (commentId: string) =&gt; {
    setExpandedThreads((prev) =&gt; {
      const next = new Set(prev);
      if (next.has(commentId)) {
        next.delete(commentId);
      } else {
        next.add(commentId);
      }
      return next;
    });
  };

  const handleRatingSelect = (index: number) =&gt; {
    const value = index + 1;
    setRating(value);
    setHoverRating(value);
    if (formError) setFormError(null);
  };

  const handleRatingHover = (index: number) =&gt; {
    setHoverRating(index + 1);
  };

  const handleRatingLeave = () =&gt; {
    setHoverRating(rating);
  };

  const handleEditingRatingSelect = (index: number) =&gt; {
    const value = index + 1;
    setEditingRating(value);
    setEditingHoverRating(value);
    if (editError) setEditError(null);
  };

  const handleEditingRatingHover = (index: number) =&gt; {
    setEditingHoverRating(index + 1);
  };

  const handleEditingRatingLeave = () =&gt; {
    setEditingHoverRating(editingRating);
  };

  return {
    comments,
    hasComments,
    isLoading,
    loadError,
    actionError,
    formError,
    message,
    isSubmitting,
    activeMenuId,
    editingCommentId,
    editingValue,
    editError,
    isSavingEdit,
    replyingToId,
    replyMessage,
    replyError,
    isSubmittingReply,
    expandedThreads,
    rating,
    hoverRating,
    editingRating,
    editingHoverRating,
    onMessageChange: handleMessageChange,
    handleSubmit,
    toggleMenu,
    startEditing,
    handleCancelEdit,
    handleEditingValueChange,
    handleEdit,
    handleDelete,
    beginReply,
    handleCancelReply,
    handleReplyValueChange,
    handleSubmitReply,
    toggleThreadVisibility,
    handleRatingSelect,
    handleRatingHover,
    handleRatingLeave,
    handleEditingRatingSelect,
    handleEditingRatingHover,
    handleEditingRatingLeave,
  };
};

export { MAX_REPLY_DEPTH };
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/typescript");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
