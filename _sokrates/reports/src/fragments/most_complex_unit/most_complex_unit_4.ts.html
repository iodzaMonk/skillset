<html>
<head>
    <title>export function usePostManager()</title>
    <link rel="stylesheet" charset="UTF-8" href="https://d2bb1mtyn3kglb.cloudfront.net/lib/highlight/styles/docco.min.css">
    <script charset="UTF-8" type="application/javascript" src="https://d2bb1mtyn3kglb.cloudfront.net/lib/highlight/highlight.min.js"></script>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">export function usePostManager()</h3>
<p style="margin-top: 4px">in <i>app/myproduct/_hooks/postStates.ts [35:218]</i></p>
<ul>
    <li><b>131</b> lines of code</li>
    <li><b>19</b> McCabe index (conditional complexity)</li>
</ul>
<pre>
<code class="ts">
export function usePostManager({ userId }: UsePostManagerOptions = {}) {
  const [posts, setPosts] = useState&lt;PostBody[]&gt;([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [editingPost, setEditingPost] = useState&lt;PostBody | null&gt;(null);
  const [file, setFile] = useState&lt;File | undefined&gt;();
  const [filePreview, setFilePreview] = useState&lt;string | undefined&gt;();
  /**
   * Refreshes posts
   * @async
   */
  const refreshPosts = useCallback(async (): Promise&lt;void&gt; =&gt; {
    try {
      const data = await fetchUserProducts();
      setPosts(data);
    } catch (error) {
      console.error(&quot;Unable to load products&quot;, error);
    }
  }, []);

  useEffect(() =&gt; {
    refreshPosts();
  }, [refreshPosts]);

  /**
   * Handles submits of all kinds, uses `useCallBack()` to cache in the method in other components.
   *
   * Used for creating and updating posts
   * @async
   */
  const handleSubmit = useCallback(
    async (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; {
      event.preventDefault();
      if (!userId) {
        console.error(&quot;User must be authenticated to create a product&quot;);
        return false;
      }
      // payload
      const formData = new FormData(event.currentTarget);
      const title = (formData.get(&quot;title&quot;) as string | null)?.trim() ?? &quot;&quot;;
      const description =
        (formData.get(&quot;description&quot;) as string | null)?.trim() ?? &quot;&quot;;
      const priceInput = (formData.get(&quot;price&quot;) as string | null) ?? &quot;0&quot;;

      const price = parseFloat(priceInput);
      const category =
        (formData.get(&quot;category&quot;) as string | null)?.trim() ?? &quot;&quot;;
      console.log(category);
      if (!title || !description || Number.isNaN(price) || !category) {
        console.error(&quot;Form data is invalid&quot;);
        return false;
      }

      setIsSubmitting(true);
      try {
        let imageLocation: string | undefined;

        if (file) {
          imageLocation = await uploadImage(file);
        }

        // edit post
        // TODO: add category handle
        if (editingPost) {
          await updateProduct({
            ...editingPost,
            user_id: userId,
            title,
            description,
            price,
            image_location: imageLocation ?? editingPost.image_location,
            category,
          });
          setEditingPost(null);
        } else {
          // create post
          // TODO: add category handle
          await createProduct({
            user_id: userId,
            title,
            description,
            price,
            image_location: imageLocation,
            category,
          });
        }
        await refreshPosts();

        if (filePreview) {
          URL.revokeObjectURL(filePreview);
        }

        setFile(undefined);
        setFilePreview(undefined);
        return true;
      } catch (error) {
        console.error(&quot;Failed to create product&quot;, error);
        return false;
      } finally {
        setIsSubmitting(false);
      }
    },
    [editingPost, file, filePreview, refreshPosts, userId],
  );

  /**
   * Deletes selected post
   * @param items
   */
  const deletePosts = useCallback(
    async (items: PostBody[]) =&gt; {
      const deletions = await Promise.all(
        items.map(async (post) =&gt; {
          if (!post.id) {
            return false;
          }

          try {
            await deleteProduct(post.id);
            if (post.image_location) {
              await deleteFile(post.image_location);
            }
            return true;
          } catch (error) {
            console.error(&quot;Failed to delete product&quot;, error);
            return false;
          }
        }),
      );

      const didDeleteAny = deletions.some(Boolean);

      if (didDeleteAny) {
        await refreshPosts();
      }

      return didDeleteAny;
    },
    [refreshPosts],
  );

  const startEditing = useCallback(
    (item: PostBody) =&gt; {
      if (filePreview) {
        URL.revokeObjectURL(filePreview);
      }
      setFile(undefined);
      setFilePreview(undefined);
      setEditingPost(item);
    },
    [filePreview],
  );

  const resetEditing = useCallback(() =&gt; {
    if (filePreview) {
      URL.revokeObjectURL(filePreview);
    }
    setFile(undefined);
    setFilePreview(undefined);
    setEditingPost(null);
  }, [filePreview]);

  const handleFile = useCallback((nextFile: File | undefined) =&gt; {
    setFile(nextFile);
    setFilePreview((currentPreview) =&gt; {
      if (currentPreview) {
        URL.revokeObjectURL(currentPreview);
      }
      return nextFile ? URL.createObjectURL(nextFile) : undefined;
    });
  }, []);

  return {
    posts,
    handleSubmit,
    isSubmitting,
    deletePosts,
    editingPost,
    startEditing,
    resetEditing,
    file,
    filePreview,
    handleFile,
  };
}

</code>
</pre>
<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
