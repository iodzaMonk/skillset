<html>
<head>
    <title>features/support/productCrudFixture.ts</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">features/support/productCrudFixture.ts (<b>187</b> lines of code) (<a href="productCrudFixture.ts">raw</a>):</h3>
<div id="editor">import bcrypt from &quot;bcryptjs&quot;;
import { randomUUID } from &quot;crypto&quot;;
import { ZodError } from &quot;zod&quot;;
import {
  createProductRecord,
  updateProductRecord,
  listProductsForUser,
  deleteProductRecord,
  ProductNotFoundError,
} from &quot;../../app/lib/productCrud.ts&quot;;
import { prisma } from &quot;../../lib/prisma.ts&quot;;

type ProductResponse = {
  status: number;
  body: Record&lt;string, unknown&gt;;
};

type ProductRow = Record&lt;string, string&gt;;

export class ProductCrudFixture {
  private userId: string | null = null;
  private otherUserIds: Set&lt;string&gt; = new Set();
  private productTitles = new Map&lt;string, string&gt;();
  private trackedProductIds = new Set&lt;string&gt;();
  response: ProductResponse | null = null;

  async authenticate() {
    if (this.userId) return this.userId;
    this.userId = await this.createUser(&quot;crud-owner&quot;);
    return this.userId;
  }

  signOut() {
    this.userId = null;
  }

  async seedMyProducts(rows: ProductRow[]) {
    await this.authenticate();
    for (const row of rows) {
      const record = await createProductRecord(this.userId as string, this.toPayload(row));
      this.trackProduct(record.title ?? record.id, record.id);
    }
  }

  async seedForeignProducts(rows: ProductRow[]) {
    const ownerId = await this.createUser(`crud-foreign-${randomUUID()}`);
    this.otherUserIds.add(ownerId);
    for (const row of rows) {
      const record = await createProductRecord(ownerId, this.toPayload(row));
      this.trackedProductIds.add(record.id);
    }
  }

  async createProduct(row: ProductRow) {
    if (!this.userId) {
      this.response = {
        status: 401,
        body: { message: &quot;Not authenticated&quot; },
      };
      return;
    }

    try {
      const product = await createProductRecord(this.userId, this.toPayload(row));
      this.trackProduct(product.title ?? product.id, product.id);
      this.response = { status: 201, body: { data: product } };
    } catch (error) {
      this.response = this.normalizeError(error);
    }
  }

  async updateProduct(title: string, row: ProductRow) {
    if (!this.userId) {
      this.response = {
        status: 401,
        body: { message: &quot;Not authenticated&quot; },
      };
      return;
    }
    const productId = this.productTitles.get(title);
    if (!productId) {
      this.response = {
        status: 404,
        body: { message: &quot;Product not found&quot; },
      };
      return;
    }
    try {
      const payload = { ...this.toPayload(row), id: productId };
      const product = await updateProductRecord(this.userId, payload);
      const newTitle = product.title ?? title;
      if (newTitle !== title) {
        this.productTitles.delete(title);
        this.productTitles.set(newTitle, product.id);
      }
      this.response = { status: 200, body: { data: product } };
    } catch (error) {
      this.response = this.normalizeError(error);
    }
  }

  async listMyProducts() {
    if (!this.userId) {
      this.response = { status: 200, body: { data: [] } };
      return;
    }
    const products = await listProductsForUser(this.userId);
    this.response = { status: 200, body: { data: products } };
  }

  async deleteProduct(title: string) {
    if (!this.userId) {
      this.response = {
        status: 401,
        body: { message: &quot;Not authenticated&quot; },
      };
      return;
    }
    const productId = this.productTitles.get(title);
    if (!productId) {
      this.response = {
        status: 404,
        body: { message: &quot;Product not found&quot; },
      };
      return;
    }
    try {
      await deleteProductRecord(this.userId, productId);
      this.trackedProductIds.delete(productId);
      this.productTitles.delete(title);
      this.response = {
        status: 200,
        body: { message: &quot;Product deleted&quot; },
      };
    } catch (error) {
      this.response = this.normalizeError(error);
    }
  }

  async cleanup() {
    if (this.trackedProductIds.size &gt; 0) {
      await prisma.posts.deleteMany({
        where: { id: { in: Array.from(this.trackedProductIds) } },
      });
    }
    this.trackedProductIds.clear();
    if (this.userId) {
      await prisma.users.delete({ where: { id: this.userId } }).catch(() =&gt; null);
      this.userId = null;
    }
    if (this.otherUserIds.size &gt; 0) {
      await prisma.users.deleteMany({
        where: { id: { in: Array.from(this.otherUserIds) } },
      });
      this.otherUserIds.clear();
    }
    this.productTitles.clear();
    this.response = null;
  }

  private trackProduct(title: string, id: string) {
    this.trackedProductIds.add(id);
    this.productTitles.set(title, id);
  }

  private toPayload(row: ProductRow) {
    const payload: Record&lt;string, unknown&gt; = {};
    for (const [key, rawValue] of Object.entries(row)) {
      if (rawValue === undefined) continue;
      payload[key] = rawValue;
    }
    return payload;
  }

  private normalizeError(error: unknown): ProductResponse {
    if (error instanceof ZodError) {
      return {
        status: 400,
        body: { message: error.issues.map((i) =&gt; i.message).join(&quot;, &quot;) },
      };
    }
    if (error instanceof ProductNotFoundError) {
      return {
        status: 404,
        body: { message: error.message },
      };
    }
    throw error;
  }

  private async createUser(prefix: string) {
    const hashed = await bcrypt.hash(&quot;CrudPass123!&quot;, 10);
    const user = await prisma.users.create({
      data: {
        name: prefix,
        email: `${prefix}-${randomUUID()}@example.com`,
        password: hashed,
        country: &quot;US&quot;,
      },
      select: { id: true },
    });
    return user.id;
  }
}
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/typescript");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
